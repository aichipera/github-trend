# [编写玩具程序的纯粹乐趣](20250625-software_is_joy.mp3)

> - 作者: Joshua Barretto
> - 原文: https://blog.jsbarretto.com/post/software-is-joy

> **译者注**: 作者的核心观点——“我无法创造之物，我便无法理解”——在今天这个 AI 工具日益强大的时代，显得尤为珍贵。许多开发者可能正沦为“API 调用工程师”，对底层原理知之甚少。本文倡导的“玩具项目”正是对抗这种趋势的良药。它鼓励我们放下对效率的极致追求，回归本心，通过亲手打造一个操作系统、一个编译器或一个游戏模拟器，来获得最深刻的理解和最纯粹的快乐。这不仅是学习，更是一种修行。

为什么你应该多写些“玩具”程序

___

我是物理学家理查德·费曼那句名言的忠实拥趸：

> **「我无法创造之物，我便无法理解」**

我认为这句话闪耀着智慧的光芒，并且在许多领域都颠扑不破（只要你愿意对“创造”的定义稍作引申）。我相信，我所真正擅长的一切，都归功于这一原则。有些人会告诉你不要“重复造轮子”，但他们错了：你*就应该*亲手造一个自己的轮子，因为这比读一千本关于轮子的书，更能让你深刻理解它们的工作原理。

在 2025 年的今天，编写软件之美与匠心正在被侵蚀。AI 扬言要取代我们（至少是我们这门手艺中最富乐趣的部分），软件开发也正被日益商品化、被量化、被打包、被工业化。软件开发需要更多纯粹的快乐，而我发现，创造“玩具”程序是让我回想起当初为何与计算机为伴的绝佳方式。

## 保持简单

玩具程序遵循“二八定律”：用 20% 的工作，实现 80% 的功能。其重点*并非*要构建生产级别的软件（尽管许多最优秀的生产软件确实是从一个玩具项目开始的）。要极力避免过度设计，将自己限制在实现目标所必需的代码上。让所有代码路径都直接崩溃 (panic/crash)，直到你为了取得进展而不得不实现它为止。你可能会惊讶地发现，构建那些你曾认为难于上青天的软件的“玩具”版本，其实是如此简单。

## 其他益处

我总是惊讶地发现，那些我在做玩具项目时学到的一些晦涩难懂的知识点，在我的日常工作中竟然会变得极具价值。它们要么让我在追踪工具或库中的问题时抢占先机，要么让我在错误发生之前就将其识别出来。

理解那些定义了软件形态的约束条件，对于使用该软件至关重要。而要洞察这些约束，没有比一头扎进去、亲身撞上它们更好的方法了。你甚至可能因此想出一些新颖的解决方案！

## 项目清单

以下是我在过去 15 年里尝试过的一些玩具程序清单，附有难度和所需时间的评级。这些评级是估算值，前提是你已经熟练掌握至少一种通用编程语言，并且像我一样，每天通常只有一到两个小时的空闲时间来写代码。清单中还包括一些我认为有用的参考资源。

### 正则表达式引擎 (难度 = 4/10, 耗时 = 5 天)

一个能够读取 POSIX 风格的正则表达式并识别匹配字符串的引擎。正则表达式看似简单却表现力惊人，编写一个合格的正则引擎会教会你所有关于使用这门语言的知识。

* [维基百科：正则表达式 (英文)][1]

### x86 操作系统内核 (难度 = 7/10, 耗时 = 2 个月)

一个兼容 multiboot 标准的操作系统内核，包含简单的命令行界面 (CLI)、键盘/鼠标驱动、ANSI 转义序列支持、内存管理器、调度器等。额外的挑战包括：编写一个内存文件系统、实现用户模式和进程隔离、加载 ELF 可执行文件，以及支持足以渲染图形用户界面 (GUI) 的视频硬件。

*  [OS Dev Wiki][2]
* [Tupai OS 内核][3]

![Tupai OS 内核][fig1]

### GameBoy/NES 模拟器 (难度 = 6/10, 耗时 = 3 周)

一个能运行最简单的 GameBoy 或 NES 游戏的简陋模拟器。GB 和 NES 都是经典之作，它们的指令集和外围硬件都相对简单。额外的挑战包括：编写合格的图像处理单元 (PPU) 和可编程声音发生器 (PSG) 实现，以及处理一些更奇特的卡带格式。

* [GB Dev][4]
* [NES Dev Wiki][5]

### GameBoy Advance 游戏 (难度 = 3/10, 耗时 = 2 周)

一个基于精灵的 2D 游戏（俯视角或横版平台跳跃）。GBA 是一个非常适合编程的美丽小主机，并且拥有一个活跃而专注的开发社区。我坚信，GBA 是最后一个能被单个开发者从头到脚、甚至精确到指令周期都完全理解的游戏机之一。

* [Tonc (GBA 编程教程)][6]
* [GBATEK (GBA 技术文档)][7]

### 物理引擎 (难度 = 5/10, 耗时 = 1 周)

一个实现牛顿物理学的 2D 刚体物理引擎，支持矩形、圆形等。最简单的版本，比如只实现相互推开的球体，是很容易的。但当你引入更复杂的形状、角动量等时，事情就开始变得复杂。额外的挑战包括：使碰撞解析快速且可扩展、让复杂的交互随时间趋于稳定状态、软体交互等。

### 动态解释器 (难度 = 4/10, 耗时 = 1-2 周)

一个用于类 JavaScript 语言的树遍历解释器，支持基本流程控制。可以为此添加的东西无穷无尽，但能用自己的语言编写程序至今仍能给我带来孩童般的喜悦。这感觉像是一种技术创世：一旦你有了自己的语言，你就可以开始在其中构建整个宇宙。

* [Crafting Interpreters (《手把手教你构建解释器》)][8]
* [Forge 语言解释器][9]

![Forge 语言解释器][fig2]
### 类 C 语言的编译器 (难度 = 8/10, 耗时 = 3 个月)

一个为简单类型的类 C 语言编写的编译器，至少支持一种目标架构。额外的挑战包括：实现一些最常见的优化（如内联、常量折叠、循环不变量外提等），以及设计一个足够通用的中间表示 (IR) 来支持多种后端。

### 文本编辑器 (难度 = 5/10, 耗时 = 2-4 周)

这个项目的难度变化很大。最简单的，用几行 Python 读写文件就能完成。但要构建一个接近日常使用的编辑器，就会复杂得多。你可以选择使用 QT 或 GTK 等工具包来实现 UI，但我个人更喜欢在终端中工作的编辑器。正确处理 Unicode、语法高亮、光标移动、多缓冲区支持、窗格/窗口、标签页、搜索/查找功能、LSP 支持等，每一项都可能增加一周到一个月的工作量。但如果你坚持下去，你可能会跻身于那些使用自己创造的编辑器的开发者精英之列。

[ZTE 文本编辑器][10]

![ZTE 文本编辑器][fig3]

### 异步运行时 (难度 = 6/10, 耗时 = 1 周)

“异步”在不同语言中具体含义差异很大。至少在 Rust 中，这意味着一个可以接收 `impl Future` 任务并并发轮询直至完成的库。增加对 I/O 唤醒的支持会是一个有趣的挑战。

### 哈希表 (Hash Map) (难度 = 4/10, 耗时 = 3-5 天)

哈希表（或者在更高级的语言中称为集合/字典）是程序员的看家本领。然而，令人惊讶的是，我们中很少有人真正理解它们底层的运作方式。你可以尝试各种技术：封闭寻址或开放寻址、墓碑标记、罗宾汉算法等。你会体会到它们在何时何地表现优异，以及何时你其实应该只用一个向量 + 线性搜索。

* [罗宾汉哈希应成为你默认的哈希表实现 (英文)][11]

### 光栅化器 / 纹理映射器 (难度 = 6/10, 耗时 = 2 周)

我们大多数人都玩过简单的 3D 图形，但有多少人真正理解图形管线是如何工作的？更重要的是，当它不工作时，我们知道如何修复它吗？编写自己的软件光栅化器会赋予你这些知识，同时让你对矢量数学和半空间之美产生新的欣赏，这些知识在许多其他领域也有应用。额外的复杂性包括：正确实现裁剪、Z-缓冲、N边形光栅化、透视校正纹理映射、Phong 或 Gouraud 着色、阴影映射等。

* [Scratch-A-Pixel (从零学习计算机图形学)][12]
* [OpenGL 是如何工作的：500 行代码实现软件渲染 (英文)][13]

[![euc 光栅化器][fig4]][14]

### SDF 渲染 (难度 = 5/10, 耗时 = 3 天)

有向距离场 (Signed Distance Fields, SDF) 是一种用数学方式定义和渲染 3D 空间的美妙而简单的方法，非常适合用于演示场景 (demoscene) 的着色器。只需相对较少的工作，你就可以构建一个可爱的小型可视化效果或一些像 80 年代图形演示那样的移动形状。你还会对 着色器语言 (Shader) 和矢量数学有更深的理解。

* [Inigo Quilez 的网站 (SDF 大神)][15]
* [ShaderToy (在线着色器创作平台)][16]
* [有向距离场示例][17]

![有向距离场示例][fig5]

### 体素引擎 (难度 = 5/10, 耗时 = 2 周)

我怀疑读这篇文章的人很少有没玩过《我的世界》(Minecraft) 的。构建一个类似风格的玩具体素引擎出奇地容易，特别是如果你已经具备一些 3D 图形或游戏开发的知识。体素引擎的简单性，加上它们所能表达的近乎无限的创造力，总能让我充满喜悦。可以通过添加纹理、更复杂的过程式生成、泛光填充照明、碰撞、动态流体、通过网络发送体素数据等来增加复杂性。

* [0 FPS: Minecraft 游戏中的网格化 (英文)][18]

### 线程化虚拟机 (Threaded Virtual Machine) (难度 = 6/10, 耗时 = 1 周)

编写解释器非常有趣。什么更有趣？*更快的解释器*。如果你在不进行特定架构代码生成（如 AOT 或 JIT）的情况下，将解释器的性能推向极致，你最终会（重新）发现*线程化代码 (Threaded Code)*（不要与多线程 (Multi-threading) 混淆，这是完全不同的东西）。这是一种将程序由高度优化的微型程序编织在一起的美妙方式，一个好的实现甚至可以在性能上与 AOT 编译器一较高下。

* [维基百科：线程化代码 (英文)][19]
* [muforth.dev: 线程化代码 (英文)][20]

### GUI 工具包 (难度 = 6/10, 耗时 = 2-3 周)

我们大多数人可能都用 tkinter、GTK、QT 或 WinForms 拼凑过一个 GUI 程序。但为什么不试试编写自己的 GUI 工具包呢？额外的复杂性包括：实现一个合格的布局引擎、良好的文本塑形（包括 Unicode 支持）、无障碍支持等等。友情提醒：除非你的工具经过*实战检验*，否则不要鼓励别人使用它——这个世界已经有太多几乎没有无障碍或本地化支持的 GUI 了。

* [YouTube: Clay 的 UI 算法如何工作 (英文)][21]
* [GUI 工具包示例][22]

![GUI 工具包示例][fig6]
### 轨道力学模拟 (难度 = 6/10, 耗时 = 1 周)

一个简单的牛顿引力模拟可以在相当短的时间内拼凑出来。众所周知，超过两个物体的引力系统无法解析求解，所以你必须熟悉迭代式的*积分*方法。额外的复杂性来自于实现更精确、更快的积分方法，考虑相对论效应，以及编写一个可视化工具。如果你的数学是正确的，你甚至可以尝试代入 NASA 的真实数据来预测下一次涨潮或满月。

* [维基百科：蛙跳积分法 (英文)][23]

### 位挑战 (Bitwise Challenge) (难度 = 3/10, 耗时 = 2-3 天)

这是我为自己设计的一个挑战，但我认为它会成为一个很棒的 Game Jam 主题：编写一个在连续帧之间只持久化 64 位状态的游戏。没错，所有东西只有 64 位：整个逐帧的游戏状态必须仅用 64 位数据就能重现。这听起来很简单，但它迫使你在游戏状态管理方面发挥出惊人的创造力。规则详情可以在下面的 GitHub 页面找到。

* [位挑战 (The Bitwise Challenge)][24]
* [位挑战贪吃蛇游戏][25]

![位挑战贪吃蛇游戏][fig7]
### 一个 ECS 框架 (难度 = 4/10, 耗时 = 1-2 周)

致所有游戏开发者：尝试构建自己的 [ECS (实体组件系统)][26] 框架。它并不像你想象的那么难（你可能已经无意中做过了！）。如果你能构建安全性和正确性特性，并与你所选编程语言的类型系统特性良好集成，那就更棒了。

由于平台的独特性能和内存限制，我为我的 [GBA 上的超级马里奥 64][27] 项目构建了一个定制的 ECS，并且非常享受这个过程。

<iframe width="100%" height="600ch" src="https://www.youtube.com/embed/nS5rj80L-pk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

### CHIP-8 模拟器 (难度 = 3/10, 耗时 = 3-6 天)

[CHIP-8][28] 是一个源自 70 年代的美丽而简单的虚拟机。你可以在一两天内编写一个完全兼容的模拟器，并且有大量粉丝制作的游戏可以在上面运行。[这是][29]我为它做的一个游戏。

* [维基百科：CHIP-8 (英文)][30]

[![Emul8 模拟器][fig8]][31]

### 国际象棋引擎 (难度 = 5/10, 耗时 = 2-5 天)

编写一个国际象棋引擎非常有趣。一开始，它走的每一步棋可能都是非法的，但随着时间的推移，它会变得越来越聪明。被自己编写的象棋引擎击败，真的是一种必经的仪式，感觉妙不可言。

* [维基百科：极小化极大算法 (Minimax)][32]
* [维基百科：Alpha-beta 剪枝][33]

![国际象棋引擎][fig9]

### POSIX shell (难度 = 4/10, 耗时 = 3-5 天)

我们每天都与 shell 交互，构建一个自己的 shell 会让你学到大量关于 POSIX 的知识——它是如何工作的，以及它在哪些地方并不那么好用。一个简单的 shell 一天就能完成，但要兼容现有的 shell 语言则需要时间，并且会让你了解到比你想象中更多的关于它的怪癖。

* [用 C 语言写一个 Shell (英文)][34]

[![Tosh shell][fig10]][35]

## 关于学习和大型语言模型 (LLM) 的一点说明

也许你是 LLM 的用户。我理解，它们是很好的工具，对某些类型的学习很有用。但我建议，在进行这类项目时，请抵制使用它们的诱惑。知识本不该是盛在盘子里喂给你的。如果你想要那种学习方式，去读一本书——构建这类玩具项目的乐趣来自于对未知的探索，而不是用一个现成的解决方案来污染自己的思想。如果你已经使用 LLM 一段时间了，这种“冷火鸡”式的方法一开始可能会很痛苦，但请坚持下去。没有痛苦，就没有快乐。

**跑步者的快感，坐公交的人是体会不到的。**

[fig1]: https://gitlab.com/zesterer/tupai/-/raw/master/doc/images/tupai-0-5-0.png
[fig2]: https://blog.jsbarretto.com/img/forge.webp
[fig3]: https://github.com/zesterer/zte/raw/master/misc/screenshot.png
[fig4]: https://github.com/zesterer/euc/raw/master/misc/example.png
[fig5]: https://blog.jsbarretto.com/img/sdf-shapes.webp
[fig6]: https://github.com/zesterer/gui/raw/master/misc/example.png
[fig7]: https://blog.jsbarretto.com/img/snake.webp
[fig8]: https://github.com/zesterer/emul8/raw/master/misc/screenshot.png
[fig9]: https://blog.jsbarretto.com/img/chess.webp
[fig10]: https://raw.githubusercontent.com/zesterer/tosh/master/misc/screen0.png

[1]: https://en.wikipedia.org/wiki/Regular_expression#Syntax
[2]: https://wiki.osdev.org/
[3]: https://gitlab.com/zesterer/tupai
[4]: https://gbdev.io/
[5]: https://www.nesdev.org/wiki/Nesdev_Wiki
[6]: https://www.coranac.com/tonc/text/toc.htm
[7]: https://problemkaputt.de/gbatek.htm
[8]: https://craftinginterpreters.com/
[9]: https://github.com/zesterer/forge
[10]: https://github.com/zesterer/zte
[11]: https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/
[12]: https://www.scratchapixel.com/
[13]: https://github.com/ssloy/tinyrenderer/wiki/Lesson-0:-getting-started
[14]: https://github.com/zesterer/euc
[15]: https://iquilezles.org/articles/distfunctions/
[16]: https://www.shadertoy.com/
[17]: https://www.shadertoy.com/view/ftXBWs
[18]: https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/
[19]: https://en.wikipedia.org/wiki/Threaded_code
[20]: https://muforth.dev/threaded-code/
[21]: https://www.youtube.com/watch?v=by9lQvpvMIc
[22]: https://github.com/zesterer/gui
[23]: https://en.wikipedia.org/wiki/Leapfrog_integration
[24]: https://github.com/zesterer/the-bitwise-challenge
[25]: https://github.com/zesterer/bitwise-examples
[26]: https://en.wikipedia.org/wiki/Entity_component_system
[27]: https://www.youtube.com/watch?v=nS5rj80L-pk
[28]: https://en.wikipedia.org/wiki/CHIP-8
[29]: https://github.com/zesterer/emul8/raw/refs/heads/master/test/test.ch8
[30]: https://en.wikipedia.org/wiki/CHIP-8
[31]: https://github.com/zesterer/emul8
[32]: https://en.wikipedia.org/wiki/Minimax
[33]: https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning
[34]: https://brennan.io/2015/01/16/write-a-shell-in-c/
[35]: https://github.com/zesterer/tosh

---

# Hacker News网友热议

> 热议: https://news.ycombinator.com/item?id=44367084
## LLM：是超级搜索引擎还是学习的拐杖？

关于是否在“玩具项目”中使用LLM，评论区产生了激烈的讨论。许多开发者表示，他们主要将LLM用作一个增强版的搜索引擎，类似于“2010年时期的谷歌，感觉像一种超能力”。他们用LLM来快速比较技术（如MySQL vs. MongoDB）、生成样板代码（Terraform配置、gRPC接口）、解释不熟悉的API或解决“就在嘴边想不起来”的术语问题。一位用户形容其为“猎犬”，能帮忙探路，但最终的决策和实现仍需自己完成。

> 我很少让它做任何创新性的工作，只是将现有项目的想法转换到我的项目中。创新的工作是我自己享受编码乐趣的部分。

然而，另一派观点则对此持谨慎甚至反对态度。他们认为，知识不应该被“直接端上盘子”。学习的真正价值在于尝试、失败、研究和理解的过程。

> 他们说我们从错误中学习。请不要让这个聪明的机器阻止你犯错。它不是老师，也不知道如何教育人。

这派开发者担心，过度依赖LLM会让人跳过关键的思考和挣扎环节，从而无法建立深刻的理解。有人分享经验说，LLM给出的技术答案常常“在重要细节上存在微妙的错误”，直接采纳可能会浪费数小时甚至数天的时间。此外，一个普遍的担忧是，随着“生成式引擎优化”（GEO）的兴起，LLM的回答可能会像今天的搜索引擎一样，被广告和商业偏见所污染，最终变得不再可靠。

> 有人说，如果你不使用LLM，你就会落后。我开始认为，从长远来看，*不使用*它们将是一个显著的优势。

## 玩具项目的价值：从建立自信到职业跃升

许多评论者分享了通过构建玩具项目获得巨大回报的经历。一位用户在离职后的六个月里，为自己设定了“每个项目一周内完成”的挑战。这种在短时间内从零到一的经历，极大地增强了他的自信，并让他重新发现了编程的乐趣。

> 如果你发现自己有机会在两份工作之间休息几个月，别去刷 LeetCode 了，就去构建一些玩具项目吧——你会惊讶于自己已经懂得多少。

另一则被广泛认同的轶事来自一位Dart语言的开发者。他在自己的玩具语言项目中艰难地实现了Maranget的“完备性检查”算法。正是通过这个“玩具”级别的实践，他才真正理解了算法的精髓，并最终将其成功地应用、扩展到了更为复杂的Dart语言中，解决了一个核心技术难题。这个故事有力地证明了，玩具项目不仅是学习工具，其积累的知识和经验完全可能在未来的专业工作中发挥关键作用。

同时，不少人建议将这些玩具项目发布到GitHub上。一位招聘经理表示，一个拥有几个真实提交记录的GitHub个人资料是“‘这个人真的会写代码吗？’这个问题的最佳答案”，能让你在简历筛选中脱颖而出。

## “修自己的自行车” vs. “修明天上班要骑的自行车”

一个广受赞誉的比喻将写玩具软件比作修理自己的自行车、汽车或船。

> 修自己的自行车是种乐趣。但修理你明天上班必须骑的那辆自行车，就充满了压力。

这个比喻精准地描绘了个人项目与生产级软件之间的区别。当一个项目没有外部用户、没有截止日期、没有SLA（服务等级协议）时，开发者可以纯粹享受创造和解决问题的过程。但一旦这个项目被用于实际生产（比如自托管的邮件服务器），或者有其他人依赖它时，乐趣就会迅速被责任和压力所取代。许多开发者表示，他们更喜欢开发仅供自己使用的软件，因为“功能在Safari上用不了？谁在乎呢，我反正不用Safari。”

## 对时间估算的质疑

尽管文章的核心理念获得了广泛赞同，但许多评论者对作者给出的项目时间估算表示怀疑。例如“物理引擎（1周）”或“GameBoy Advance游戏（2周）”等估算被认为“极其乐观”。有经验的开发者指出，如果有人做一个哈希映射都需要3-5天，那么他不可能在7天内完成一个线程虚拟机。

作者本人后来回应称，这些估算的前提是项目仅仅是“玩具”或“概念验证”级别，而非功能完备、可用于生产的软件。其目的是快速探索一个未知领域，而不是打造一个完美的产品。这个澄清也得到了大家的认可：玩具项目的关键在于过程而非最终成品。

---
# 💡 灵感碰撞工坊

这篇文章真是让人热血沸腾！看完作者的清单，你是否也燃起了亲手创造的欲望？欢迎在下方分享你的想法：

1.  **你的“玩具箱”里有什么？** 分享一个你做过的、或者一直想做的“玩具项目”，无论大小。
2.  **挑战哪个？** 在作者的清单里，哪个项目最让你心动？你觉得最大的挑战会是什么？
3.  **AI 是帮手还是“剧透”？** 对于作者提出的“在做玩具项目时远离 LLM”的建议，你怎么看？你会在学习和探索时使用 AI 吗？
4.  **补充你的清单！** 除了文中的项目，你还能想到哪些很酷的“玩具项目”点子？